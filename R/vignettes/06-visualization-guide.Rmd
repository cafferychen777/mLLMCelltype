---
title: "Visualization Guide"
author: "Chen Yang"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    theme: flatly
vignette: >
  %\VignetteIndexEntry{Visualization Guide}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  eval = FALSE,
  fig.width = 10,
  fig.height = 6
)
```

<img src="../man/figures/logo.png" align="right" height="139" alt="mLLMCelltype logo" />

# Visualization Guide

This guide provides detailed instructions for visualizing mLLMCelltype results. Creating effective visualizations is crucial for interpreting cell type annotations and communicating uncertainty metrics in your single-cell RNA sequencing analysis.

## Basic Visualization Concepts

mLLMCelltype provides three key types of information that can be visualized:

1. **Cell Type Annotations**: The final cell type labels assigned to each cluster
2. **Consensus Proportion**: A measure of agreement among models (0-1)
3. **Shannon Entropy**: A measure of uncertainty in the annotations (lower is better)

These can be visualized separately or combined into informative multi-panel figures.

## Integrating with Seurat

### Adding mLLMCelltype Results to Seurat Objects

Before visualization, you need to add the mLLMCelltype results to your Seurat object:

```{r}
library(Seurat)
library(mLLMCelltype)
library(ggplot2)
library(patchwork)

# Assuming you have a Seurat object named 'seurat_obj' and consensus results
# First, check the structure of consensus_results
# Print the structure of consensus_results to understand its format
# str(consensus_results)
# print(names(consensus_results))
# print(names(consensus_results$final_annotations))

# Get cluster IDs from Seurat object
cluster_ids <- unique(as.character(Idents(seurat_obj)))
cat("Cluster IDs in Seurat object:", paste(cluster_ids, collapse=", "), "\n")

# Convert final_annotations to a vector if it's a list
final_annotations <- unlist(consensus_results$final_annotations)
cat("Final annotations:", paste(names(final_annotations), collapse=", "), "\n")

# Create a mapping between cluster IDs and annotations
annotation_map <- vector("character", length(cluster_ids))
names(annotation_map) <- cluster_ids

# First, try direct mapping where cluster ID matches the name in final_annotations
for (i in seq_along(cluster_ids)) {
  cluster_id <- cluster_ids[i]
  # Check if this cluster ID exists in final_annotations names
  if (cluster_id %in% names(final_annotations)) {
    annotation_map[cluster_id] <- final_annotations[cluster_id]
  }
}

# For any remaining unmapped clusters, try to infer the mapping
unmapped <- is.na(annotation_map) | annotation_map == ""
if (any(unmapped)) {
  unmapped_ids <- names(annotation_map)[unmapped]
  cat("Unmapped cluster IDs:", paste(unmapped_ids, collapse=", "), "\n")

  # If we have the same number of unmapped clusters as remaining annotations,
  # we can try to assign them in order
  remaining_annotations <- final_annotations[!names(final_annotations) %in% names(annotation_map)[!unmapped]]

  if (length(remaining_annotations) == length(unmapped_ids)) {
    for (i in seq_along(unmapped_ids)) {
      annotation_map[unmapped_ids[i]] <- remaining_annotations[i]
    }
  } else {
    # If we can't map directly, assign "Unknown" to unmapped clusters
    for (id in unmapped_ids) {
      annotation_map[id] <- paste("Unknown", id)
    }
  }
}

cat("Final annotation map:\n")
print(annotation_map)

# Add consensus annotations to Seurat object
seurat_obj$cell_type_consensus <- plyr::mapvalues(
  x = as.character(Idents(seurat_obj)),
  from = names(annotation_map),
  to = as.character(annotation_map)
)

# Verify the annotations were added correctly
table(seurat_obj$cell_type_consensus, as.character(Idents(seurat_obj)))

# Extract consensus metrics from the consensus results
# Check if consensus_results has the expected structure
if (!is.null(consensus_results$initial_results) &&
    !is.null(consensus_results$initial_results$consensus_results)) {

  # Get consensus metrics
  consensus_metrics <- lapply(
    names(consensus_results$initial_results$consensus_results),
    function(cluster_id) {
      metrics <- consensus_results$initial_results$consensus_results[[cluster_id]]
      return(list(
        cluster = cluster_id,
        consensus_proportion = metrics$consensus_proportion,
        entropy = metrics$entropy
      ))
    }
  )

  # Convert to data frame for easier handling
  metrics_df <- do.call(rbind, lapply(consensus_metrics, data.frame))

  # Create a mapping for consensus proportion
  proportion_map <- metrics_df$consensus_proportion
  names(proportion_map) <- metrics_df$cluster

  # Print the proportion map for debugging
  cat("Consensus proportion map:\n")
  print(proportion_map)

  # Create a mapping for entropy
  entropy_map <- metrics_df$entropy
  names(entropy_map) <- metrics_df$cluster

  # Print the entropy map for debugging
  cat("Entropy map:\n")
  print(entropy_map)

  # Add consensus proportion to Seurat object
  # First check if all cluster IDs are in the proportion map
  missing_clusters <- setdiff(cluster_ids, names(proportion_map))
  if (length(missing_clusters) > 0) {
    cat("Warning: Some clusters are missing from proportion map:",
        paste(missing_clusters, collapse=", "), "\n")
    # Add default values for missing clusters
    for (cluster in missing_clusters) {
      proportion_map[cluster] <- 1.0  # Default to perfect consensus
    }
  }

  seurat_obj$consensus_proportion <- as.numeric(plyr::mapvalues(
    x = as.character(Idents(seurat_obj)),
    from = names(proportion_map),
    to = as.character(proportion_map)
  ))

  # Add entropy to Seurat object
  # First check if all cluster IDs are in the entropy map
  missing_clusters <- setdiff(cluster_ids, names(entropy_map))
  if (length(missing_clusters) > 0) {
    cat("Warning: Some clusters are missing from entropy map:",
        paste(missing_clusters, collapse=", "), "\n")
    # Add default values for missing clusters
    for (cluster in missing_clusters) {
      entropy_map[cluster] <- 0.0  # Default to no uncertainty
    }
  }

  seurat_obj$entropy <- as.numeric(plyr::mapvalues(
    x = as.character(Idents(seurat_obj)),
    from = names(entropy_map),
    to = as.character(entropy_map)
  ))

  # Verify metrics were added correctly
  summary(seurat_obj$consensus_proportion)
  summary(seurat_obj$entropy)
} else {
  # If the expected structure is not found, create dummy metrics
  warning("Could not find consensus metrics in the results. Creating dummy metrics for visualization purposes.")

  # Create dummy metrics
  seurat_obj$consensus_proportion <- 1.0  # Perfect consensus
  seurat_obj$entropy <- 0.0  # No uncertainty
}
```

### Basic Visualization with Seurat

#### Cell Type Annotations

```{r}
# Basic cell type visualization
p1 <- DimPlot(seurat_obj,
              group.by = "cell_type_consensus",
              label = TRUE,
              repel = TRUE) +
  ggtitle("Cell Type Annotations") +
  theme(plot.title = element_text(hjust = 0.5))

p1
```

#### Consensus Proportion

```{r}
# Visualize consensus proportion
p2 <- FeaturePlot(seurat_obj,
                 features = "consensus_proportion",
                 cols = c("yellow", "green", "blue"),
                 min.cutoff = 0.3,
                 max.cutoff = 1) +
  ggtitle("Consensus Proportion") +
  theme(plot.title = element_text(hjust = 0.5))

p2
```

#### Shannon Entropy

```{r}
# Visualize Shannon entropy
p3 <- FeaturePlot(seurat_obj,
                 features = "entropy",  # Note: The column name is 'entropy', not 'shannon_entropy'
                 cols = c("red", "orange", "yellow"),
                 min.cutoff = 0,
                 max.cutoff = 1.5) +
  scale_color_gradient(low = "red", high = "yellow") +
  ggtitle("Shannon Entropy") +
  theme(plot.title = element_text(hjust = 0.5))

p3
```

#### Combined Visualization

```{r}
# Combine all three visualizations
p1 | p2 | p3
```

## Publication-Ready Visualizations with SCpubr

For publication-quality visualizations, we recommend using the SCpubr package, which provides enhanced aesthetics for single-cell visualizations:

```{r}
# Install SCpubr if not already installed
if (!requireNamespace("SCpubr", quietly = TRUE)) {
  remotes::install_github("enblacar/SCpubr")
}

library(SCpubr)

# Cell type annotations with SCpubr
# Note: Check SCpubr documentation for the correct parameters
# The 'title' parameter might not be supported in your version of SCpubr
p1 <- SCpubr::do_DimPlot(seurat_obj,
                         group.by = "cell_type_consensus",
                         label = TRUE,
                         repel = TRUE,
                         legend.position = "right",
                         font.size = 14,
                         pt.size = 0.5)

# Add title using ggplot2 if needed
p1 <- p1 + ggtitle("Cell Type Annotations") +
  theme(plot.title = element_text(hjust = 0.5))

# Consensus proportion with SCpubr
p2 <- SCpubr::do_FeaturePlot(seurat_obj,
                            features = "consensus_proportion",
                            order = TRUE,
                            pt.size = 0.5,
                            colors.use = c("yellow", "green", "blue"),
                            legend.position = "right",
                            font.size = 14)

# Add title using ggplot2
p2 <- p2 + ggtitle("Consensus Proportion") +
  theme(plot.title = element_text(hjust = 0.5))

# Shannon entropy with SCpubr
p3 <- SCpubr::do_FeaturePlot(seurat_obj,
                            features = "entropy",  # Note: The column name is 'entropy', not 'shannon_entropy'
                            order = TRUE,
                            pt.size = 0.5,
                            colors.use = c("red", "orange", "yellow"),
                            legend.position = "right",
                            font.size = 14)

# Add title using ggplot2
p3 <- p3 + ggtitle("Shannon Entropy") +
  theme(plot.title = element_text(hjust = 0.5))

# Combine plots with patchwork
combined_plot <- p1 | p2 | p3

# Add a common title
combined_plot <- combined_plot +
  plot_annotation(
    title = "mLLMCelltype Results",
    theme = theme(plot.title = element_text(size = 16, hjust = 0.5, face = "bold"))
  )

combined_plot
```

## Advanced Visualization Techniques

### Highlighting Controversial Clusters

You can highlight clusters with low consensus or high uncertainty:

```{r}
# Create a new column to identify controversial clusters
seurat_obj$controversial <- ifelse(seurat_obj$consensus_proportion < 0.5, "Controversial", "Consensus")

# Visualize controversial clusters
p_controversial <- SCpubr::do_DimPlot(seurat_obj,
                  group.by = "controversial",
                  colors.use = c("Controversial" = "red", "Consensus" = "blue"),
                  label = FALSE,
                  pt.size = 0.5)

# Add title using ggplot2
p_controversial <- p_controversial +
  ggtitle("Controversial vs. Consensus Clusters") +
  theme(plot.title = element_text(hjust = 0.5))

p_controversial
```

### Visualizing Model Agreement

To visualize how different models agree or disagree:

```{r}
# Assuming you have individual model results in the Seurat object
# Create a function to calculate agreement with consensus
calculate_agreement <- function(seurat_obj, model_column, consensus_column) {
  seurat_obj$agreement <- ifelse(
    seurat_obj[[model_column]] == seurat_obj[[consensus_column]],
    "Agrees with consensus",
    "Disagrees with consensus"
  )
  return(seurat_obj)
}

# Apply to each model
models <- c("claude_3_7_sonnet", "gpt_4o", "gemini_1_5_pro")
plot_list <- list()

for (model in models) {
  column_name <- paste0("cell_type_", model)
  temp_obj <- calculate_agreement(seurat_obj, column_name, "cell_type_consensus")

  # Create plot with SCpubr
  p_temp <- SCpubr::do_DimPlot(temp_obj,
                              group.by = "agreement",
                              colors.use = c("Agrees with consensus" = "darkgreen",
                                            "Disagrees with consensus" = "darkred"),
                              pt.size = 0.5)

  # Add title using ggplot2
  plot_list[[model]] <- p_temp +
    ggtitle(paste0(model, " Agreement")) +
    theme(plot.title = element_text(hjust = 0.5))
}

# Combine all agreement plots
wrap_plots(plot_list, ncol = 2)
```

### Heatmap of Model Predictions

Create a heatmap to visualize all model predictions for each cluster:

```{r}
library(pheatmap)

# Create a matrix of model predictions for each cluster
create_prediction_matrix <- function(consensus_results, models) {
  n_clusters <- length(consensus_results$final_annotations)
  prediction_matrix <- matrix(NA, nrow = n_clusters, ncol = length(models))
  rownames(prediction_matrix) <- paste0("Cluster_", 0:(n_clusters-1))
  colnames(prediction_matrix) <- models

  # Extract individual model predictions from initial_results
  initial_predictions <- consensus_results$initial_results$individual_predictions

  for (i in 1:length(models)) {
    model <- models[i]
    if (model %in% names(initial_predictions)) {
      predictions <- initial_predictions[[model]]
      # Convert predictions to a vector if it's a list
      if (is.list(predictions)) {
        pred_vector <- unlist(predictions)
        prediction_matrix[, i] <- pred_vector
      } else {
        prediction_matrix[, i] <- predictions
      }
    }
  }

  return(prediction_matrix)
}

# Convert cell type names to numeric codes for visualization
encode_cell_types <- function(prediction_matrix) {
  unique_types <- unique(as.vector(prediction_matrix))
  # Remove NA values before creating mapping
  unique_types <- unique_types[!is.na(unique_types)]
  type_mapping <- setNames(1:length(unique_types), unique_types)

  encoded_matrix <- matrix(NA, nrow = nrow(prediction_matrix), ncol = ncol(prediction_matrix))
  rownames(encoded_matrix) <- rownames(prediction_matrix)
  colnames(encoded_matrix) <- colnames(prediction_matrix)

  for (i in 1:nrow(prediction_matrix)) {
    for (j in 1:ncol(prediction_matrix)) {
      if (!is.na(prediction_matrix[i, j])) {
        encoded_matrix[i, j] <- type_mapping[prediction_matrix[i, j]]
      }
    }
  }

  return(list(matrix = encoded_matrix, mapping = type_mapping))
}

# Create and plot the heatmap
models <- c("claude-3-7-sonnet-20250219", "gpt-4o", "gemini-1.5-pro")
prediction_matrix <- create_prediction_matrix(consensus_results, models)
encoded_data <- encode_cell_types(prediction_matrix)

# Extract metrics for annotation row
metrics_df <- do.call(rbind, lapply(consensus_metrics, data.frame))

# Add consensus and uncertainty metrics as annotations
annotation_row <- data.frame(
  Consensus = consensus_results$final_annotations,
  Proportion = metrics_df$consensus_proportion,
  Entropy = metrics_df$entropy
)
rownames(annotation_row) <- rownames(prediction_matrix)

# Create color scales
n_types <- length(encoded_data$mapping)
cell_type_colors <- colorRampPalette(rainbow(n_types))(n_types)
names(cell_type_colors) <- 1:n_types

proportion_colors <- colorRampPalette(c("yellow", "green", "blue"))(100)
entropy_colors <- colorRampPalette(c("red", "orange", "yellow"))(100)

annotation_colors <- list(
  Proportion = proportion_colors,
  Entropy = entropy_colors
)

# Plot heatmap
pheatmap(
  encoded_data$matrix,
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  annotation_row = annotation_row,
  annotation_colors = annotation_colors,
  main = "Model Predictions by Cluster",
  fontsize = 10,
  cellwidth = 30,
  cellheight = 30,
  legend = TRUE,
  display_numbers = TRUE,
  number_format = function(x) names(encoded_data$mapping)[encoded_data$mapping == x]
)
```

## Visualizing Discussion Logs

The discussion logs contain valuable information about the reasoning process. Here's how to visualize key aspects:

```{r}
library(tidytext)
library(wordcloud)
library(stringr)

# Extract discussion text for a specific cluster
extract_discussion_text <- function(consensus_results, cluster_id) {
  discussion_logs <- consensus_results$discussion_logs
  if (is.null(discussion_logs) || !cluster_id %in% names(discussion_logs)) {
    return(NULL)
  }

  # Extract text from discussion logs
  discussion_log <- discussion_logs[[cluster_id]]

  # Combine all text from all rounds
  all_text <- ""
  if (!is.null(discussion_log$rounds)) {
    for (round in discussion_log$rounds) {
      if (!is.null(round$responses)) {
        for (model_name in names(round$responses)) {
          response <- round$responses[[model_name]]
          if (is.character(response)) {
            all_text <- paste(all_text, response, sep = " ")
          }
        }
      }
    }
  }

  return(all_text)
}

# Create a word cloud from discussion text
create_discussion_wordcloud <- function(discussion_text, title = "Discussion Word Cloud", output_file = NULL) {
  # Clean and tokenize text
  words <- discussion_text %>%
    str_remove_all("[[:punct:]]") %>%
    str_remove_all("[[:digit:]]") %>%
    str_to_lower() %>%
    str_split("\\s+") %>%
    unlist()

  # Remove stop words
  stop_words <- c("the", "and", "a", "to", "of", "is", "in", "that", "this", "it", "as", "for", "with", "be", "are", "on", "by", "an", "or", "at", "but", "not", "from", "have", "has", "was", "were")
  words <- words[!words %in% stop_words]

  # Count word frequencies
  word_freq <- table(words)
  word_freq <- sort(word_freq, decreasing = TRUE)

  # Create word cloud
  if (!is.null(output_file)) {
    # If output file is specified, save to file
    png(output_file, width = 800, height = 600, res = 100)
    par(mar = c(0, 0, 2, 0))
    wordcloud(names(word_freq), freq = word_freq, min.freq = 2, max.words = 100,
              random.order = FALSE, colors = brewer.pal(8, "Dark2"), main = title)
    title(main = title)
    dev.off()
  } else {
    # Otherwise display in the current device
    par(mar = c(0, 0, 2, 0))
    wordcloud(names(word_freq), freq = word_freq, min.freq = 2, max.words = 100,
              random.order = FALSE, colors = brewer.pal(8, "Dark2"), main = title)
    title(main = title)
  }
}

# Example usage
cluster_id <- "0"  # Replace with the cluster you want to visualize
discussion_text <- extract_discussion_text(consensus_results, cluster_id)
if (!is.null(discussion_text) && nchar(discussion_text) > 0) {
  # Save to file
  output_file <- paste0("wordcloud_cluster_", cluster_id, ".png")
  create_discussion_wordcloud(
    discussion_text,
    title = paste("Cluster", cluster_id, "Discussion Keywords"),
    output_file = output_file
  )
  cat("Word cloud saved to:", output_file, "\n")
} else {
  cat("No discussion text found for cluster", cluster_id, "\n")
}
```

## Saving Visualizations

To save your visualizations for publications or presentations:

```{r}
# Save a single plot
ggsave("cell_type_annotations.png", plot = p1, width = 10, height = 8, dpi = 300)

# Save the combined plot
ggsave("mLLMCelltype_results.png", plot = combined_plot, width = 15, height = 8, dpi = 300)

# Save as PDF for vector graphics
ggsave("mLLMCelltype_results.pdf", plot = combined_plot, width = 15, height = 8)
```

## Visualization Best Practices

### Color Selection

- **Cell Type Annotations**: Use distinct colors for different cell types
- **Consensus Proportion**: Use a gradient from yellow (low) to blue (high)
- **Shannon Entropy**: Use a gradient from red (low uncertainty) to yellow (high uncertainty)

### Layout Considerations

- Arrange plots in a logical order (annotations, consensus, entropy)
- Use consistent point sizes and fonts across plots
- Include informative titles and legends
- Consider adding cluster labels for easier reference

### Accessibility

- Choose colorblind-friendly palettes when possible
- Include text labels in addition to colors
- Ensure sufficient contrast for readability
- Consider alternative representations for complex data

## Example: Complete Visualization Workflow

Here's a complete example workflow for creating publication-ready visualizations:

```{r}
library(Seurat)
library(mLLMCelltype)
library(ggplot2)
library(patchwork)
library(SCpubr)

# Load data and results
# Assuming you have a Seurat object and consensus results

# Add results to Seurat object
seurat_obj$cell_type_consensus <- plyr::mapvalues(
  x = as.character(Idents(seurat_obj)),
  from = as.character(0:(length(consensus_results$final_annotations)-1)),
  to = consensus_results$final_annotations
)

# Extract consensus metrics from the consensus results
consensus_metrics <- lapply(names(consensus_results$initial_results$consensus_results), function(cluster_id) {
  metrics <- consensus_results$initial_results$consensus_results[[cluster_id]]
  return(list(
    cluster = cluster_id,
    consensus_proportion = metrics$consensus_proportion,
    entropy = metrics$entropy
  ))
})

# Convert to data frame for easier handling
metrics_df <- do.call(rbind, lapply(consensus_metrics, data.frame))

# Add consensus proportion to Seurat object
seurat_obj$consensus_proportion <- as.numeric(plyr::mapvalues(
  x = as.character(Idents(seurat_obj)),
  from = metrics_df$cluster,
  to = metrics_df$consensus_proportion
))

# Add entropy to Seurat object
seurat_obj$entropy <- as.numeric(plyr::mapvalues(
  x = as.character(Idents(seurat_obj)),
  from = metrics_df$cluster,
  to = metrics_df$entropy
))

# Create publication-ready visualizations
# Cell type annotations with SCpubr
p1 <- SCpubr::do_DimPlot(seurat_obj,
                         group.by = "cell_type_consensus",
                         label = TRUE,
                         repel = TRUE,
                         legend.position = "right",
                         font.size = 14,
                         pt.size = 0.5)

# Add title using ggplot2
p1 <- p1 + ggtitle("Cell Type Annotations") +
  theme(plot.title = element_text(hjust = 0.5))

# Consensus proportion with SCpubr
p2 <- SCpubr::do_FeaturePlot(seurat_obj,
                            features = "consensus_proportion",
                            order = TRUE,
                            pt.size = 0.5,
                            colors.use = c("yellow", "green", "blue"),
                            legend.position = "right",
                            font.size = 14)

# Add title using ggplot2
p2 <- p2 + ggtitle("Consensus Proportion") +
  theme(plot.title = element_text(hjust = 0.5))

# Shannon entropy with SCpubr
p3 <- SCpubr::do_FeaturePlot(seurat_obj,
                            features = "entropy",  # Note: The column name is 'entropy', not 'shannon_entropy'
                            order = TRUE,
                            pt.size = 0.5,
                            colors.use = c("red", "orange", "yellow"),
                            legend.position = "right",
                            font.size = 14)

# Add title using ggplot2
p3 <- p3 + ggtitle("Shannon Entropy") +
  theme(plot.title = element_text(hjust = 0.5))

# Combine plots
combined_plot <- p1 | p2 | p3

# Add annotation
combined_plot <- combined_plot +
  plot_annotation(
    title = "mLLMCelltype Results",
    subtitle = "Cell type annotations with uncertainty metrics",
    caption = "Created with mLLMCelltype and SCpubr",
    theme = theme(
      plot.title = element_text(size = 16, hjust = 0.5, face = "bold"),
      plot.subtitle = element_text(size = 12, hjust = 0.5),
      plot.caption = element_text(size = 10, hjust = 1)
    )
  )

# Save the visualization
ggsave("mLLMCelltype_visualization.png",
       plot = combined_plot,
       width = 15,
       height = 8,
       dpi = 300)

# Also save as PDF for vector graphics
ggsave("mLLMCelltype_visualization.pdf",
       plot = combined_plot,
       width = 15,
       height = 8)
```

## Troubleshooting Common Issues

### SCpubr Parameter Compatibility

If you encounter errors with SCpubr functions:

- The `title` parameter may not be supported in your version of SCpubr
- Use standard ggplot2 functions to add titles instead:

```r
p <- p + ggtitle("My Title") + theme(plot.title = element_text(hjust = 0.5))
```

- Check the SCpubr documentation for your installed version

### Handling NA Values

When working with model predictions:

- Always check for and handle NA values in matrices
- Use `unique_types <- unique_types[!is.na(unique_types)]` to remove NA values
- Add conditional checks like `if (!is.na(prediction_matrix[i, j]))` in loops

### Discussion Log Extraction

If you have trouble extracting discussion text:

- The structure of discussion logs may vary
- Use a more robust extraction approach that navigates through the nested structure
- Check that the text is not empty with `nchar(discussion_text) > 0`

### Wordcloud Dependencies

If wordcloud generation fails:

- Ensure all required packages are installed: `wordcloud`, `RColorBrewer`, `tm`
- Consider saving to a file with `png()` and `dev.off()` instead of displaying directly
- Increase memory limits if working with large text corpora

## Next Steps

Now that you know how to create effective visualizations for mLLMCelltype results, you can explore:

- [FAQ](07-faq.html): Find answers to common questions
- [Advanced Features](08-advanced-features.html): Explore hierarchical annotation and other advanced features
- [Contributing Guide](09-contributing-guide.html): Learn how to contribute to the project
- [Version History](10-version-history.html): Review the development history of mLLMCelltype
